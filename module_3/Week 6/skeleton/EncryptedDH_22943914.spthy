theory EncryptedDH
begin

/* Signed Diffie-Hellman protocol, first attempt:
   A -> B : A, aenc_B{g^x}  (x fresh)
   B -> A : B, aenc_A{g^y, h(g^x)}  (y fresh)
   A -> B : A, aenc_B{h(g^y)}  */


/* ----------------- */
/* Equational theory */
/* ----------------- */

/* Load the built-in Diffie-Hellman, asymmetric encryption and hashing equational theories */
builtins: diffie-hellman, asymmetric-encryption, hashing


/* ------------------ */
/* Key infrastructure */
/* ------------------ */

rule GenKey:  // generate long-term key pair, publish the public key
   [ Fr(~kA) ] 
   -->
   [ !Key($A, ~kA),  // notation: !Fact = persistent fact, not consumed by rules
     !Pk($A, pk(~kA)),
     Out(pk(~kA)) 
   ]

/*----------------*/
/* Protocol rules */
/*----------------*/

/* Question 1 here */

/* A -> B : A, aenc_pkB{g^x}  (x fresh) */
rule Init_1:
  let 
    gxI = 'g'^~xI // gX
    anec_pkB_gX = aenc(gxI, pkB)
  in 
    [
      Fr(~xI), // fresh private key xI
      !Pk($B, pkB),// get the public key from B
      !Key($A, skA)
      
    ]
    -->
    [ Init_1($A, $B, ~xI, gxI, skA, pkB),  // <~X, gX>
      Out(<$A, anec_pkB_gX>) // aenc_pkB{g^x}
    ] 

/* B -> A : B, aenc_A{g^y, h(g^x)}  (y fresh) */
rule Resp_1:
  let 
    gyR = 'g'^~yR // gY
    gX = adec(aenc(gxI, pkB), skB)
    pair = aenc(<gyR, h(gX)>, pkA)
    gxy = gX^~yR
  in 
    [ 
      Fr(~yR), // fresh private key A # A â†’ B : A, aencpkB{g x} x fresh
      !Key($B, skB),
      !Pk($A, pkA),
      In(<$A, aenc(gxI, pkB)>) //A, aenc(gxI, pk(skB)) pattern matching 
    ] // get hash public key A from A
    --[RunningR($B, $A, gxy)]->
    [ 
      Resp_1($B, $A, ~yR, gyR, gX, skB, gxy),  // <~Y, gyR>
      Out(<$B, pair>)
    ] 

/* A -> B : A, aenc_B{h(g^y)} */
rule Init_2:
  let 
    pair = aenc(<gyR, h(gxI)>, pkA)
    kI = fst(adec(pair, skA))^~xI // (g^y)^~xI
  in   
    [ 
      Init_1($A, b, ~xI, gxI, skA, pkB),
      In(<b, aenc(<gyR, h(gxI)>, pkA)>)
    ]         
    --[ 
      Eq(h(gxI), snd(adec(pair, skA))),
      FinishedI($A),           // finish initiator 
      SecretI($A, b, kI),
      CommitI($A, b, kI),
      RunningI($A, b, kI)
      
    ]->   
    [ // update the state (this is not necessary, since this is the last initiator rule)
      Out(<$A, aenc(h(fst(adec(pair, skA))), pkB)>)
    ]    // aenc_B{h(g^y)}

// A & B agree on g^xy
rule Resp_2:
    [ 
      Resp_1($B, a, ~yR, gyR, gX, skB, gxy),
      In(<a, aenc(h(gyR), pkB)>)
    ]               
    --[ 
      Eq(h(gyR), adec(aenc(h(gyR), pkB), skB)),
      FinishedR($B),               // finish responder    
      SecretR(a, $B, gxy),
      CommitR($B, a, gxy)
    ]->        // update the state (this is not necessary, since this is the last responder rule)
    []  // finish 

/* ---------- */
/* Key Reveal */
/* ---------- */

/* Question 2 here */

rule k:
 [!Key(A, k)]
 --[Compromised(A)]->
 [Out(k)]

/* ---------- */
/* Restrictions */
/* ---------- */

restriction equality:
"All x y #i. Eq(x,y) @i ==> x = y"


/* ---------- */
/* Properties */
/* ---------- */

/* Executability checks */
lemma executableI:
exists-trace "Ex #i A. FinishedI(A) @ i & not (Ex #j B. Compromised(B)@j)"

lemma executableR:
exists-trace "Ex #i B. FinishedR(B) @ i & not (Ex #j B. Compromised(B)@j)"


/* Key secrecy:  (Question 3)
   in all traces, if a key is marked as secret between two uncompromised agents,
   then the attacker cannot learn it */


lemma key_secrecyI:
"All #i A B k.
 (SecretI(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"

lemma key_secrecyR:
"All #i A B k.
 (SecretR(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"



/* Key agreement:  (Question 4)
Please uncomment the following two lemmas for this question.
*/


lemma agreementR:
"All #i A B k.
  (CommitR( B, A, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningI(A, B, k) @ j & j < i)"



lemma agreementI:
"All #i A B k.
  (CommitI(A, B, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningR(B, A, k) @ j & j < i)"






end



