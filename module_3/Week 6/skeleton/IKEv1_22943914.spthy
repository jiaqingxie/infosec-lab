theory IKEv1
begin

/* IKEv1 protocol:
   A -> B : aenc_B{A}, aenc_B{N_A}, g^x  (N_A fresh nonce, x fresh)
   B -> A : aenc_A{B}, aenc_A{N_B}, g^y, HASH_B  (y fresh)
   A -> B : HASH_A
where:
   HASH_R = prf(<skID, g^x, g^y, A, B>)
   HASH_I = prf(<skID, g^y, g^x, B, A>)
   skID = prf(<h(<N_A, N_B>), A, B>)

*/

/* ----------------- */
/* Equational theory */
/* ----------------- */

/* Load the built-in Diffie-Hellman and signature equational theories */
builtins: diffie-hellman, asymmetric-encryption, hashing

/*Define an abstract function prf with no additional algebraic properties
representing a "perfect" pseudo-random function. */
functions: prf/1


/* ------------------ */
/* Key infrastructure */
/* ------------------ */

rule genkey:
   [ Fr(~kA) ] 
   -->
   [ !Key($A, ~kA),
     !Pk($A, pk(~kA)),
     Out(pk(~kA)) ]

/* Question 7*/

/*----------------*/
/* Protocol rules */
/*----------------*/

//  aenc_B{A}, aenc_B{N_A}, g^x  (N_A fresh nonce, x fresh)
rule Init_1:
  let 
    //gX = 
    anec_pkB_A = aenc($A, pkB)
    anec_pkB_Na = aenc(~Na, pkB)
  in 
    [
      Fr(~X),  // x fresh
      Fr(~Na), // Na fresh nonce
      !Pk($B, pkB),
      !Key($A, skA)
    ]
    -->
    [ Init_1($A, $B, ~X,'g'^~X , skA, pkB, ~Na),  
      Out(<anec_pkB_A, anec_pkB_Na, 'g'^~X >) // Out (<enc_pkB(A), enc_pkB(Na), gX>)
    ] 

rule Resp_1:
  let 
    gY = 'g'^~Y // gY
    gxy = gX^~Y
    Na_ = adec(anec_pkB_Na, skB)
    skID = prf(<h(<Na_, ~Nb>), $A, $B>)
    HashB = prf(<skID, gY, gX, $B, $A>)
    aenc_pkA_B = aenc($B, pkA)
    aenc_pkA_Nb = aenc(~Nb, pkA)
    KAB = prf(<skID, gxy>)
  in 
    [ 
      Fr(~Y), 
      Fr(~Nb),
      !Key($B, skB),
      !Pk($A, pkA),
      In(<anec_pkB_A, anec_pkB_Na, gX>) 
    ] 
    --[
        Eq($A, adec(anec_pkB_A, skB)),
        RunningR($B, $A, KAB)]->
    [ 
      Resp_1($B, $A, ~Y, gY, gX, skB, gxy, pkA, ~Nb, Na_, KAB, skID),  
      Out(<aenc_pkA_B, aenc_pkA_Nb, gY, HashB>)
    ] 

//HASH_A
rule Init_2:
  let 
    gxy = gY^~X
    Nb_ = adec(aenc_pkA_Nb, skA)
    skID_byA = prf(<h(<~Na, Nb_>), $A, $B>)
    HashB_byA = prf(<skID_byA, gY, gX, $B, $A>)
    HashA = prf(<skID_byA, gX, gY, $A, $B>)
    KAB = prf(<skID_byA, gxy>)
  in   
    [ 
      Init_1($A, $B, ~X, gX, skA, pkB, ~Na),
      In(<aenc_pkA_B, aenc_pkA_Nb, gY, HashB>)
    ]         
    --[ 
      Eq($B, adec(aenc_pkA_B, skA)),
      Eq(HashB, HashB_byA),
      FinishedI($A),           
      SecretI($A, $B, KAB),
      CommitI($A, $B, KAB),
      RunningI($A, $B, KAB)
    ]->   
    [ 
      Out(HashA)
    ]    

rule Resp_2:
  let 
    HashA_byB = prf(<skID, gX, gY, $A, $B>)
  in
    [ 
      Resp_1($B, $A, ~Y, gY, gX, skB, gxy, pkA, ~Nb, Na_, KAB, skID),
      In(HashA)
    ]               
    --[ 
      Eq(HashA, HashA_byB),
      FinishedR($B),             
      SecretR($A, $B, KAB),
      CommitR($B, $A, KAB)
    ]->        
    []  // finish 


/* ---------- */
/* Key Reveal */
/* ---------- */

rule k:
 [!Key(A, k)]
 --[Compromised(A)]->
 [Out(k)]





/* ---------- */
/* Restrictions */
/* ---------- */

restriction equality:
"All x y #i. Eq(x,y) @i ==> x = y"


/* ---------- */
/* Properties */
/* ---------- */

/* Executability checks */
lemma executableI:
exists-trace "Ex #i A. FinishedI(A) @ i & not (Ex #j B. Compromised(B)@j)"

lemma executableR:
exists-trace "Ex #i B. FinishedR(B) @ i & not (Ex #j B. Compromised(B)@j)"


/* Secrecy and agreement properties */

lemma key_secrecyI:
"All #i A B k.
 (SecretI(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"

lemma key_secrecyR:
"All #i A B k.
 (SecretR(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"


lemma agreementR:
"All #i A B k.
  (CommitR( B, A, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningI(A, B, k) @ j & j < i)"

lemma agreementI:
"All #i A B k.
  (CommitI( A, B, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningR(B, A, k) @ j & j < i)"



/* Perfect Forward Secrecy:  (Question 8)
Please uncomment the following two lemmas for this question.
*/



lemma secrecy_PFS_R:
 " All A B k #i. 
    SecretR(A, B, k) @i &
      not ((Ex #l. (Compromised(A) @ l & l<i )) | (Ex #m. (Compromised(B) @ m & m < i)) )  
    ==> not (Ex #j. K(k)@j )"

lemma secrecy_PFS_I:
 " All A B k #i. 
    SecretI(A, B, k) @i &
      not ((Ex #l. (Compromised(A) @ l & l<i )) | (Ex #m. (Compromised(B) @ m & m < i)) )  
    ==> not (Ex #j. K(k)@j )"



end



