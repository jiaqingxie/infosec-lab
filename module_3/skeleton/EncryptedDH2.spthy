theory EncryptedDH2
begin

/* Signed Diffie-Hellman protocol, second attempt:
   A -> B : A, aenc_B{A, g^x}  (x fresh)
   B -> A : B, aenc_A{B, g^y, h(g^x)}  (y fresh)
   A -> B : A, aenc_B{A, h(g^y)}  */


/* ----------------- */
/* Equational theory */
/* ----------------- */

/* Load the built-in Diffie-Hellman, asymmetric encryption and hashing equational theories */
builtins: diffie-hellman, asymmetric-encryption, hashing



/* ------------------ */
/* Key infrastructure */
/* ------------------ */

rule genkey: 
   [ Fr(~kA) ] 
   -->
   [ !Key($A, ~kA),  
     !Pk($A, pk(~kA)),
     Out(pk(~kA)) ]


/* Question 6*/

/*----------------*/
/* Protocol rules */
/*----------------*/


//   A -> B : A, aenc_B{A, g^x}  (x fresh)
rule Init_1:
  let 
    gxI = 'g'^~xI // gX
    anec_pkB_gX = aenc(<$A, gxI>, pkB)
  in 
    [
      Fr(~xI), 
      !Pk($B, pkB), 
      !Key($A, skA)
    ]
    -->
    [ Init_1($A, $B, ~xI, gxI, skA, pkB),
      Out(anec_pkB_gX) 
    ] 

//   B -> A : B, aenc_A{B, g^y, h(g^x)}  (y fresh)
rule Resp_1:
  let 
    gyR = 'g'^~yR // gY
    gX = snd(adec(X, skB))
    pair = aenc(<$B,<gyR, h(gX)>>, pkA)
    gxy = gX^~yR
  in 
    [ 
      Fr(~yR), 
      !Key($B, skB),
      !Pk($A, pkA),
      In(X)
    ] 
    --[ Eq($A, fst(adec(X, skB))),
        RunningR($B, $A, gxy)]-> //
    [ 
      Resp_1($B, $A, ~yR, gyR, gX, skB, gxy),  // <~Y, gyR>
      Out(pair)
    ] 

//   A -> B : A, aenc_B{A, h(g^y)}  */
rule Init_2:
  let 
    gy_ = fst(snd(adec(Y, skA))) // gY
    h_gX = snd(snd(adec(Y, skA))) // hash(gX)
    kI = gy_^~xI// (g^y)^~xI
  in   
    [ 
      Init_1($A, $B, ~xI, gxI, skA, pkB),
      In(Y)
    ]         
    --[ 
      Eq(fst(adec(Y, skA)), $B),
      Eq(h(gxI), h_gX),
      CommitI($A, $B, kI),
      RunningI($A, $B, kI),
      FinishedI($A),          
      SecretI($A, $B, kI)
      
    ]->   
    [ 
      Out(aenc(<$A, h(gy_)>, pkB))
    ]    

// A & B agree on g^xy
rule Resp_2:
    [ 
      Resp_1($B, $A, ~yR, gyR, gX, skB, gxy),
      In(X)
    ]               
    --[ 
      Eq(h(gyR), snd(adec(X, skB))),
      CommitR($B, $A, gxy),
      FinishedR($B),               // finish responder    
      SecretR($A, $B, gxy)
      
    ]->        // update the state (this is not necessary, since this is the last responder rule)
    []  // finish 

/* ---------- */
/* Key Reveal */





/* ---------- */
/* Key Reveal */
/* ---------- */



rule yes:
 [!Key(A, k)]
 --[Compromised(A)]->
 [Out(k)]


/* ---------- */
/* Restrictions */
/* ---------- */

restriction equality:
"All x y #i. Eq(x,y) @i ==> x = y"


/* ---------- */
/* Properties */
/* ---------- */

/* Executability checks */
lemma executableI:
exists-trace "Ex #i A. FinishedI(A) @ i & not (Ex #j B. Compromised(B)@j)"

lemma executableR:
exists-trace "Ex #i B. FinishedR(B) @ i & not (Ex #j B. Compromised(B)@j)"


/* Secrecy and agreement properties */

lemma key_secrecyI:
"All #i A B k.
 (SecretI(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"

lemma key_secrecyR:
"All #i A B k.
 (SecretR(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"


lemma agreementR:
"All #i A B k.
  (CommitR( B, A, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningI(A, B, k) @ j & j < i)"

lemma agreementI:
"All #i A B k.
  (CommitI( A, B, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningR(B, A, k) @ j & j < i)"



end



